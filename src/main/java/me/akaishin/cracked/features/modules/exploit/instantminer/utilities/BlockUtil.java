package me.akaishin.cracked.features.modules.exploit.instantminer.utilities;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.network.play.client.CPacketAnimation;
import net.minecraft.network.play.client.CPacketEntityAction;
import net.minecraft.network.play.client.CPacketHeldItemChange;
import net.minecraft.network.play.client.CPacketPlayerTryUseItemOnBlock;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.RayTraceResult;
import net.minecraft.util.math.Vec3d;

public class BlockUtil
implements Wrapper {


    public static final List<Block> shulkerList;
    public static final List<Block> blackList;
    public static final List<Block> emptyBlocks;
    public static boolean canBreak(BlockPos blockPos) {
        IBlockState iBlockState = BlockUtil.mc.world.getBlockState(blockPos);
        Block block = iBlockState.getBlock();
        return block.getBlockHardness(iBlockState, BlockUtil.mc.world, blockPos) != -1.0f;
    }
    public static boolean placeBlock(BlockPos blockPos, int n, boolean bl, boolean bl2) {
        if (BlockUtil.isBlockEmpty(blockPos)) {
            EnumFacing[] enumFacingArray = new EnumFacing[0];
            int n2 = -1;
            if (n != BlockUtil.mc.player.inventory.currentItem) {
                n2 = BlockUtil.mc.player.inventory.currentItem;
                BlockUtil.mc.player.inventory.currentItem = n;
            }
            if (n2 != -1) {
                BlockUtil.mc.player.inventory.currentItem = n2;
            }
        }
        return false;
    }
    public static boolean isBlockEmpty(BlockPos blockPos) {
        block3: {
            try {
                if (!emptyBlocks.contains(BlockUtil.mc.world.getBlockState(blockPos).getBlock())) break block3;
                AxisAlignedBB axisAlignedBB = new AxisAlignedBB(blockPos);
                for (Entity entity : BlockUtil.mc.world.loadedEntityList) {
                    if (!(entity instanceof EntityLivingBase) || !axisAlignedBB.intersects(entity.getEntityBoundingBox())) continue;
                    return false;
                }
            }
            catch (Exception exception) {
                // empty catch block
            }
            return true;
        }
        return false;
    }
    public static void placeBlock(BlockPos blockPos, EnumFacing enumFacing, EnumHand enumHand) {
        EnumFacing enumFacing2 = enumFacing.getOpposite();
        BlockPos blockPos2 = blockPos.offset(enumFacing);
        Vec3d vec3d = new Vec3d(blockPos2).add(0.5, 0.5, 0.5).add(new Vec3d(enumFacing2.getDirectionVec()).scale(0.5));
        BlockUtil.rightClickBlock(blockPos2, vec3d, enumHand, enumFacing2, true);
    }

    public static void placeBlock(Vec3d vec3d, EnumHand enumHand, boolean bl, boolean bl2) {
        BlockPos blockPos = BlockUtil.vec3toBlockPos(vec3d);
        EnumFacing enumFacing = BlockUtil.getFirstFacing(blockPos);
        if (enumFacing == null) {
            return;
        }
        BlockPos blockPos2 = blockPos.offset(enumFacing);
        EnumFacing enumFacing2 = enumFacing.getOpposite();
        Vec3d vec3d2 = new Vec3d(blockPos2).add(0.5, 0.5, 0.5).add(new Vec3d(enumFacing2.getDirectionVec()).scale(0.5));
        Block block = BlockUtil.mc.world.getBlockState(blockPos2).getBlock();
        if (!BlockUtil.mc.player.isSneaking() && (blackList.contains(block) || shulkerList.contains(block))) {
            BlockUtil.mc.player.connection.sendPacket(new CPacketEntityAction(BlockUtil.mc.player, CPacketEntityAction.Action.START_SNEAKING));
            BlockUtil.mc.player.setSneaking(true);
        }
        if (bl) {
            RotationUtil.faceVector(vec3d2, true);
        }
        BlockUtil.rightClickBlock(blockPos2, vec3d2, enumHand, enumFacing2, bl2);
    }
    public static BlockPos vec3toBlockPos(Vec3d vec3d, boolean bl) {
        if (bl) {
            return new BlockPos(Math.floor(vec3d.x), Math.floor(vec3d.y), Math.floor(vec3d.z));
        }
        return new BlockPos(Math.floor(vec3d.x), (double)Math.round(vec3d.y), Math.floor(vec3d.z));
    }
    public static BlockPos vec3toBlockPos(Vec3d vec3d) {
        return new BlockPos(Math.floor(vec3d.x), (double)Math.round(vec3d.y), Math.floor(vec3d.z));
    }
    public static List<EnumFacing> getPossibleSides(BlockPos blockPos) {
        ArrayList<EnumFacing> arrayList = new ArrayList<>();
        for (EnumFacing enumFacing : EnumFacing.values()) {
            BlockPos blockPos2 = blockPos.offset(enumFacing);
            if (!BlockUtil.mc.world.getBlockState(blockPos2).getBlock().canCollideCheck(BlockUtil.mc.world.getBlockState(blockPos2), false) || BlockUtil.mc.world.getBlockState(blockPos2).getMaterial().isReplaceable()) continue;
            arrayList.add(enumFacing);
        }
        return arrayList;
    }
    public static void rightClickBlock(BlockPos blockPos, Vec3d vec3d, EnumHand enumHand, EnumFacing enumFacing) {
        float f = (float)(vec3d.x - (double)blockPos.getX());
        float f2 = (float)(vec3d.y - (double)blockPos.getY());
        float f3 = (float)(vec3d.z - (double)blockPos.getZ());
        BlockUtil.mc.player.connection.sendPacket(new CPacketPlayerTryUseItemOnBlock(blockPos, enumFacing, enumHand, f, f2, f3));
        BlockUtil.mc.player.swingArm(EnumHand.MAIN_HAND);
    }
    public static EnumFacing getFirstFacing(BlockPos blockPos) {
        Iterator<EnumFacing> iterator = BlockUtil.getPossibleSides(blockPos).iterator();
        if (iterator.hasNext()) {
            return iterator.next();
        }
        return null;
    }
    public static void placeBlock(BlockPos blockPos, EnumHand enumHand, boolean bl, boolean bl2) throws Exception {
        EnumFacing enumFacing = BlockUtil.getFirstFacing(blockPos);
        if (enumFacing == null) {
            return;
        }
        BlockPos blockPos2 = blockPos.offset(enumFacing);
        EnumFacing enumFacing2 = enumFacing.getOpposite();
        Vec3d vec3d = new Vec3d(blockPos2).add(0.5, 0.5, 0.5).add(new Vec3d(enumFacing2.getDirectionVec()).scale(0.5));
        Block block = BlockUtil.mc.world.getBlockState(blockPos2).getBlock();
        if (!BlockUtil.mc.player.isSneaking() && (blackList.contains(block) || shulkerList.contains(block))) {
            BlockUtil.mc.player.connection.sendPacket(new CPacketEntityAction(BlockUtil.mc.player, CPacketEntityAction.Action.START_SNEAKING));
            BlockUtil.mc.player.setSneaking(true);
        }
        if (bl) {
            RotationUtil.faceVector(vec3d, true);
        }
        BlockUtil.rightClickBlock(blockPos2, vec3d, enumHand, enumFacing2, bl2);
        // Use reflection to set rightClickDelayTimer
        Field field = Minecraft.class.getDeclaredField("rightClickDelayTimer");
        field.setAccessible(true);
        field.set(BlockUtil.mc, 4);
    }

    public static void rightClickBlock(BlockPos blockPos, Vec3d vec3d, EnumHand enumHand, EnumFacing enumFacing, boolean bl) {
        if (bl) {
            float f = (float)(vec3d.x - (double)blockPos.getX());
            float f2 = (float)(vec3d.y - (double)blockPos.getY());
            float f3 = (float)(vec3d.z - (double)blockPos.getZ());
            BlockUtil.mc.player.connection.sendPacket(new CPacketPlayerTryUseItemOnBlock(blockPos, enumFacing, enumHand, f, f2, f3));
        } else {
            BlockUtil.mc.playerController.processRightClickBlock(BlockUtil.mc.player, BlockUtil.mc.world, blockPos, enumFacing, vec3d, enumHand);
        }
        BlockUtil.mc.player.swingArm(EnumHand.MAIN_HAND);
    }
    public static boolean placeBlock(BlockPos blockPos, EnumHand enumHand, boolean bl) throws Exception {
        boolean bl2 = false;
        EnumFacing enumFacing = null;
        Iterator<EnumFacing> iterator = BlockUtil.getPossibleSides(blockPos).iterator();
        if (iterator.hasNext()) {
            enumFacing = iterator.next();
        }
        if (enumFacing == null) {
            return bl;
        }
        BlockPos blockPos2 = blockPos.offset(enumFacing);
        EnumFacing enumFacing2 = enumFacing.getOpposite();
        Vec3d vec3d = new Vec3d(blockPos2).add(0.5, 0.5, 0.5).add(new Vec3d(enumFacing2.getDirectionVec()).scale(0.5));
        Block block = BlockUtil.mc.world.getBlockState(blockPos2).getBlock();
        if (!BlockUtil.mc.player.isSneaking() && (blackList.contains(block) || shulkerList.contains(block))) {
            BlockUtil.mc.player.connection.sendPacket(new CPacketEntityAction(BlockUtil.mc.player, CPacketEntityAction.Action.START_SNEAKING));
            BlockUtil.mc.player.setSneaking(true);
            bl2 = true;
        }
        BlockUtil.rightClickBlock(blockPos2, vec3d, enumHand, enumFacing2);
        BlockUtil.mc.player.swingArm(EnumHand.MAIN_HAND);
        Field field = Minecraft.class.getDeclaredField("rightClickDelayTimer");
        field.setAccessible(true);
        field.set(BlockUtil.mc, 4);
        return bl2 || bl;
    }
    public static void placeCrystalOnBlock(BlockPos blockPos, EnumHand enumHand, boolean bl, boolean bl2, boolean bl3) {
        RayTraceResult rayTraceResult = BlockUtil.mc.world.rayTraceBlocks(new Vec3d(BlockUtil.mc.player.posX, BlockUtil.mc.player.posY + (double)BlockUtil.mc.player.getEyeHeight(), BlockUtil.mc.player.posZ), new Vec3d((double)blockPos.getX() + 0.5, (double)blockPos.getY() - 0.5, (double)blockPos.getZ() + 0.5));
        EnumFacing enumFacing = rayTraceResult == null || rayTraceResult.sideHit == null ? EnumFacing.UP : rayTraceResult.sideHit;
        int n = BlockUtil.mc.player.inventory.currentItem;
        int n2 = InventoryUtil.getItemHotbar(Items.END_CRYSTAL);
        if (enumHand == EnumHand.MAIN_HAND && bl3 && n2 != -1 && n2 != BlockUtil.mc.player.inventory.currentItem) {
            BlockUtil.mc.player.connection.sendPacket(new CPacketHeldItemChange(n2));
        }
        BlockUtil.mc.player.connection.sendPacket(new CPacketPlayerTryUseItemOnBlock(blockPos, enumFacing, enumHand, 0.0f, 0.0f, 0.0f));
        if (enumHand == EnumHand.MAIN_HAND && bl3 && n2 != -1 && n2 != BlockUtil.mc.player.inventory.currentItem) {
            BlockUtil.mc.player.connection.sendPacket(new CPacketHeldItemChange(n));
        }
        if (bl) {
            BlockUtil.mc.player.connection.sendPacket(new CPacketAnimation(bl2 ? enumHand : EnumHand.MAIN_HAND));
        }
    }
    public static void placeCrystalOnBlock(BlockPos blockPos, EnumHand enumHand, boolean bl, boolean bl2) {
        RayTraceResult rayTraceResult = BlockUtil.mc.world.rayTraceBlocks(new Vec3d(BlockUtil.mc.player.posX, BlockUtil.mc.player.posY + (double)BlockUtil.mc.player.getEyeHeight(), BlockUtil.mc.player.posZ), new Vec3d((double)blockPos.getX() + 0.5, (double)blockPos.getY() - 0.5, (double)blockPos.getZ() + 0.5));
        EnumFacing enumFacing = rayTraceResult == null || rayTraceResult.sideHit == null ? EnumFacing.UP : rayTraceResult.sideHit;
        BlockUtil.mc.player.connection.sendPacket(new CPacketPlayerTryUseItemOnBlock(blockPos, enumFacing, enumHand, 0.0f, 0.0f, 0.0f));
        if (bl) {
            BlockUtil.mc.player.connection.sendPacket(new CPacketAnimation(bl2 ? enumHand : EnumHand.MAIN_HAND));
        }
    }

    static {
        blackList = Arrays.asList(Blocks.ENDER_CHEST, Blocks.CHEST, Blocks.TRAPPED_CHEST, Blocks.CRAFTING_TABLE, Blocks.ANVIL, Blocks.BREWING_STAND, Blocks.HOPPER, Blocks.DROPPER, Blocks.DISPENSER, Blocks.TRAPDOOR, Blocks.ENCHANTING_TABLE);
        shulkerList = Arrays.asList(Blocks.WHITE_SHULKER_BOX, Blocks.ORANGE_SHULKER_BOX, Blocks.MAGENTA_SHULKER_BOX, Blocks.LIGHT_BLUE_SHULKER_BOX, Blocks.YELLOW_SHULKER_BOX, Blocks.LIME_SHULKER_BOX, Blocks.PINK_SHULKER_BOX, Blocks.GRAY_SHULKER_BOX, Blocks.SILVER_SHULKER_BOX, Blocks.CYAN_SHULKER_BOX, Blocks.PURPLE_SHULKER_BOX, Blocks.BLUE_SHULKER_BOX, Blocks.BROWN_SHULKER_BOX, Blocks.GREEN_SHULKER_BOX, Blocks.RED_SHULKER_BOX, Blocks.BLACK_SHULKER_BOX);
        emptyBlocks = Arrays.asList(Blocks.AIR, Blocks.FLOWING_LAVA, Blocks.LAVA, Blocks.FLOWING_WATER, Blocks.WATER, Blocks.VINE, Blocks.SNOW_LAYER, Blocks.TALLGRASS, Blocks.FIRE);
    }


    public static boolean placeBlock(BlockPos blockPos, EnumHand enumHand, boolean bl, boolean bl2, boolean bl3) {
        boolean bl4 = false;
        EnumFacing enumFacing = BlockUtil.getFirstFacing(blockPos);
        if (enumFacing == null) {
            return bl3;
        }
        BlockPos blockPos2 = blockPos.offset(enumFacing);
        EnumFacing enumFacing2 = enumFacing.getOpposite();
        Vec3d vec3d = new Vec3d(blockPos2).add(0.5, 0.5, 0.5).add(new Vec3d(enumFacing2.getDirectionVec()).scale(0.5));
        Block block = BlockUtil.mc.world.getBlockState(blockPos2).getBlock();
        if (!BlockUtil.mc.player.isSneaking() && (blackList.contains(block) || shulkerList.contains(block))) {
            BlockUtil.mc.player.connection.sendPacket(new CPacketEntityAction(BlockUtil.mc.player, CPacketEntityAction.Action.START_SNEAKING));
            BlockUtil.mc.player.setSneaking(true);
            bl4 = true;
        }
        if (bl) {
            RotationUtil.faceVector(vec3d, true);
        }
        BlockUtil.rightClickBlock(blockPos2, vec3d, enumHand, enumFacing2, bl2);
        BlockUtil.mc.player.swingArm(EnumHand.MAIN_HAND);
        return bl4 || bl3;
    }
}

